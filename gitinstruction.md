# My git instuction

![картинка](https://www.thewatchtower.com/assets/images/blog_images/how-to-use-git-version-control-in-cpanel1624580050.jpg)

* [Как задать имя пользователя и адрес электронной почты](#a)


* [Инициализация репозитория](#b)

* [Добавление отдельных файлов или всех файлов в область подготовленных файлов](#c)

* [Проверка статуса репозитория](#d)


* [Внесение изменений однострочным сообщением или через редактор](#e)


* [Просмотр истории коммитов с изменениями](#f)


* [Просмотр заданного коммита](#g)


* [Просмотр изменений до коммита](#h)


* [Удаление отслеживаемых файлов из текущего рабочего дерева](#i)


* [Отмена подготовленных и неподготовленных изменений](#j)


* [Изменение последнего коммита](#k)


* [Откат последнего коммита](#l)


* [Откат заданного коммита](#m)


* [Создание новой ветки и переход в неё](#n)


* [Просмотр списка веток](#o)


* [Удаление ветки](#p)


* [Слияние двух веток](#q)


* [Отображение журнала фиксации в виде графика для текущей или всех веток](#r)


* [Прекращение слияния при конфликте](#s)


* [Добавление удалённого репозитория](#t)


* [Просмотр удалённых URL-адресов](#u)


* [Получение дополнительных сведений об удалённом репозитории](#v)


* [Отправка изменений в удалённый репозиторий](#w)


* [Получение изменений из удалённого репозитория](#x)


* [Слияние удалённого репозитория с локальным](#y)


* [Отправка новой ветки в удалённый репозиторий](#z)


* [Удаление удалённой ветки](#a1)


* [Использование перебазирования](#b1)



<a id ="a"></a>
## Как задать имя пользователя и адрес электронной почты

Имя пользователя нужно, чтобы привязывать коммиты к вашему имени. Это не то же самое, что имя пользователя учётной записи GitHub, с помощью которого выполняется вход в профиль на GitHub. Задать или изменить имя пользователя можно с помощью команды `git config`. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. Если хотите скрыть своё реальное имя, можно использовать в качестве имени пользователя Git произвольный набор символов.

```
git config --global user.name "Tara Routray"
git config --global user.email "dev@tararoutray.com"
```
----------

<a id ="b"></a>
* ## Инициализация репозитория

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром `init`. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.
```
git init
```
---------
<a id ="c"></a>
* ## Добавление отдельных файлов или всех файлов в область подготовленных файлов

Добавить отдельный файл в область подготовленных файлов можно параметром `add` с указанием имени файла. Просто замените `somefile.js` на актуальное имя.
```
git add
```
---------
<a id ="d"></a>
* ## Проверка статуса репозитория

Просмотреть статус нужного репозитория можно по ключевому слову `status`: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.
```
git status
```


<a id ="e"></a>
* ## Внесение изменений однострочным сообщением или через редактор

При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра `commit` с флагом `-m`. Само сообщение вводится непосредственно после флага, в кавычках.

```
git commit -m "Your short summary about the commit"
```

<a id ="f"></a>
* ## Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра `log`. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг `-p`, вы можете подробно изучить изменения, внесённые в каждый файл.

```
git log -p
```

<a id ="g"></a>
* ## Просмотр заданного коммита

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра `show`, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

```
git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
```

Также можно использовать сокращённый хеш.

```
git show 1af17e
```
----------
<a id ="h"></a>
* ## Просмотр изменений до коммита

Можно просматривать список изменений, внесённых в репозиторий, используя параметр `diff`. По умолчанию отображаются только изменения, не подготовленные для фиксации.

```
git diff
```
Для просмотра подготовленных изменений необходимо добавить флаг `--staged`

```
git diff --staged
```

Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.

```
git diff somefile.js
```

---------
<a id ="i"></a>
* ## Удаление отслеживаемых файлов из текущего рабочего дерева

Удалять файлы из текущего рабочего дерева можно с помощью параметра `rm`. При этом файлы удаляются и из индекса.

```
git rm dirname/somefile.js
```

Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.

```
git rm dirname/*.html
```
---------
<a id ="j"></a>
* ## Отмена подготовленных и неподготовленных изменений

Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром checkout. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр `git checkout` изменит указатель `HEAD`, чтобы задать указанную ветку как текущую.

```
git checkout somefile.js
```

Восстановить подготовленный файл рабочего дерева можно параметром `reset`. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.

```
git reset HEAD somefile.js
```
Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.

```
git reset HEAD
```
---------
<a id ="k"></a>
* ## Изменение последнего коммита

Внести изменения в последний коммит можно параметром `commit` с флагом `--amend`. Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.

```
git commit --amend -m "Updated message for the previous commit"
```

Также можно вносить изменения в файлы, отправленные ранее. Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами `--amend` и `--no-edit`.

```
git add dir1
git commit

# Here you forgot to add dir2 to commit, you can execute the
following command to amend the other files and folders.

git add dir2
git commit --amend --no-edit
```

Флаг `--no-edit` позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.

> ## Внимание! Не изменяйте публичные коммиты.
>С помощью amend прекрасно исправляются локальные коммиты, а исправления можно передать в общий репозиторий. Однако изменять коммиты, уже доступные другим пользователям, не следует. Помните, что изменённые коммиты являются совершенно новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия будут такими же, как при отмене изменений публичного снимка.

--------------
<a id ="l"></a>
* ## Откат последнего коммита

Откатить последний коммит можно с помощью параметра `revert`. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

```
git revert HEAD
```

> Разница между `revert` и `reset`

> Команда `git revert` отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда `git reset`.

>У команды `revert` есть два крупных преимущества по сравнению с `reset`. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а `git` reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью `git reset`, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда `git revert` — гораздо более удобный и безопасный способ отмены изменений.

---------------
<a id ="m"></a>
* ## Откат заданного коммита

Откатить проект до заданного коммита можно с помощью параметра `revert` и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

```
git revert 1af17e
```
------------
<a id ="n"></a>
* ## Создание новой ветки и переход в неё

Создать новую ветку можно с помощью параметра `branch`, указав имя ветки.

```
git branch new_branch_name
```
Но `Git` не переключится на неё автоматически. Для автоматического перехода нужно добавить флаг `-b` и параметр `checkout`.

```
git checkout -b new_branch_name
```
-----------
<a id ="o"></a>
* ## Просмотр списка веток

Можно просматривать полный список веток, используя параметр `branch`. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.

```
git branch
```
Также можно вывести список удалённых веток с помощью флага `-a`.

```
git branch -a
```
------------
<a id ="p"></a>
* ## Удаление ветки

Удалить ветку можно параметром `branch` с добавлением флага `-d` и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

```
git branch -d existing_branch_name
```
Для принудительного удаления ветки используется флаг `-D` с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

```
git branch -D existing_branch_name
```

Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:

```
git push origin --delete existing_branch_name
```
--------------
<a id ="q"></a>
* ## Слияние двух веток

Объединить две ветки можно параметром `merge` с указанием имени ветки. Команда объединит указанную ветку с основной.

```
git merge existing_branch_name
```
Если надо выполнить коммит слияния, выполните команду git merge с флагом `--no-ff`.

```
git merge --no-ff existing_branch_name
```

Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.

-------------
<a id ="r"></a>
* ## Отображение журнала фиксации в виде графика для текущей или всех веток

Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра log и флагов `--graph` `--oneline` `--decorate`. Опция --graph выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами `--oneline` и `--decorate`, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.

```
git log --graph --oneline --decorate
```

ля просмотра истории коммитов по всем веткам используется флаг `--all`.

```
git log --all --graph --oneline --decorate
```
-------------
<a id ="s"></a>
* ## Прекращение слияния при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом `--abort`. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

```
git merge --abort
```

Также при конфликте слияния можно использовать параметр `reset`, чтобы восстановить конфликтующие файлы до стабильного состояния

```
git reset
```
--------------
<a id ="t"></a>
* ## Добавление удалённого репозитория

Добавить удалённый репозиторий можно параметром `remote add`, указав `shortname` и `url` требуемого репозитория.

```
git remote add awesomeapp https://github.com/someurl..
```
--------------
<a id ="u"></a>
* ## Просмотр удалённых URL-адресов

Просматривать удалённые URL-адреса можно параметром remote с флагом `-v`. Этот параметр отображает удалённые подключения к другим репозиториям.

```
git remote -v
```

Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле `.git/config` репозитория.

--------------
<a id ="v"></a>
* ## Получение дополнительных сведений об удалённом репозитории

Получить подробные сведения об удалённом репозитории можно с помощью параметра `remote show` с указанием имени репозитория — например, `origin`.

```
git remote show origin
```

Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.

----------------
<a id ="w"></a>
* ## Отправка изменений в удалённый репозиторий

Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.

```
git push origin main
```
Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.

---------------
<a id ="x"></a>
* ## Получение изменений из удалённого репозитория

Для загрузки изменений из удалённого репозитория используется параметр `pull`. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.

```
git pull
```

Также можно просмотреть подробные сведения о загруженных файлах с помощью флага `--verbose`.

```
git pull --verbose
```
--------------
<a id ="y"></a>
* ## Слияние удалённого репозитория с локальным

Слияние удалённого репозитория с локальным выполняется параметром `merge` с указанием имени удалённого репозитория.

```
git merge origin
```
---------------
<a id ="z"></a>
* ## Отправка новой ветки в удалённый репозиторий

Передать новую ветку в удалённый репозиторий можно параметром `push` с флагом `-u`, указав имя репозитория и имя ветки.

```
git push -u origin new_branch
```

--------------
<a id ="a1"></a>
* ## Удаление удалённой ветки

Чтобы избавиться от удалённой ветки, используйте параметр `push` с флагом `--delete`, указав имя удалённого репозитория и имя ветки.

```
git push --delete origin existing_branch
```
----------------
<a id ="b1"></a>
* ## Использование перебазирования

Для доступа к этой функции используйте параметр `rebase` с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.

```
git rebase branch_name
```
Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.

_______

[руководоство по git](https://github.com/cyberspacedk/Git-commands/blob/master/readme.md)

____


# Git: распространённые ошибки и способы их исправления



## Ошибка в сообщении последнего коммита

Если коммит ещё не был отправлен на сервер (push), то можно воспользоваться простой командой, позволяющей редактировать текст сообщения к последнему коммиту

```
git commit --amend
```

Эта команда откроет редактор и позволит внести изменения в последнее сообщение коммита. Никому кроме вас не стоит знать, что вы написали `«Initial commment»` с тремя `«m»`.


## Ошибка в имени ветки

Предположим, что на часах почти 15:00, а вы ещё не обедали. В результате, терзаемые голодом, вы назвали новую ветку feature-brunch. Вкуснятина, ничего не скажешь.

Эту проблему тоже можно решить. Переименовать ветку можно так же, как переименовывают файлы с помощью команды mv. Речь идёт о перемещении её в новое место с правильным именем:

```
git branch -m feature-brunch feature-branch
```
Если вы уже отправили эту ветку в репозиторий, вам, для её переименования, потребуется сделать ещё пару дел. Старую ветку надо удалить, а новую — отправить в репозиторий:

```
git push origin --delete feature-brunch
git push origin feature-branch
```

## Случайный коммит изменений в ветку master

Предположим, вы работаете над некоей новой возможностью, и, в спешке, забыли создать для неё новую ветку. Вы закоммитили уже кучу файлов и всё это лежит в ветке master. Переместить все эти изменения в новую ветку можно с помощью следующих трёх команд. Обратите внимание на то, что если вы не воспользовались, в применении к изменениям, командами `commit` или `stash`, они будут утеряны.

```
git branch feature-branch
git reset HEAD~ --hard
git checkout feature-branch
```

В результате будет создана новая ветка, будет произведён откат изменений в ветке master, до состояния, в котором она была до внесения изменений, и будет осуществлён переход в новую ветку, которая будет содержать в себе все изменения, внесённые ранее в master.


## Работа с файлами, которые забыли добавить в последний коммит

Ещё одна распространённая оплошность при работе с `Git` заключается в том, что коммиты делают слишком рано и в них не попадают нужные файлы. Скажем, вы пропустили некий файл, забыли его сохранить, или вам нужно внести небольшое изменение в файл для того, чтобы последний коммит имел смысл. В подобной ситуации вам снова пригодится команда `--amend`. Добавьте пропущенный файл в индекс репозитория и запустите эту команду:

```
git add missed-file.txt
git commit --amend
```
После этого вы можете изменить сообщение коммита, либо оставить его таким же, каким оно было.



## Добавление не того файла в репозиторий

Как быть, если ваша ошибка представляет собой полную противоположность предыдущей? Что если вы добавили в индекс файл, который не собираетесь коммитить? Это может быть какой-нибудь ENV-файл, директория сборки проекта, фото вашей собаки, которое вы случайно сохранили не в той папке. Всё это можно исправить.

Если ваши действия ограничиваются индексированием файла, но вы пока не закоммитили его, справиться с проблемой будет очень легко, воспользовавшись командой `reset`:

```
git reset /assets/img/misty-and-pepper.jpg
```
Если вы продвинулись достаточно далеко и успели изменение закоммитить, то знайте, что и это поправимо. Придётся лишь воспользоваться ещё несколькими командами:

```
git reset --soft HEAD~1
git reset /assets/img/misty-and-pepper.jpg
rm /assets/img/misty-and-pepper.jpg
git commit
```
В результате последний коммит будет отменён, изображение будет удалено, после чего новый коммит будет помещён туда, где ему положено быть.



## Что делать, если всё пошло не так?

Методика, которую мы сейчас обсудим, помогает в ситуациях, когда всё идёт не так, как надо. Например, такое происходит, когда вы слишком увлекаетесь копированием готовых решений со `StackOverflow`, и, после работы, ваш репозиторий оказывается в худшем состоянии чем он был в самом начале. В такую ситуацию, пожалуй, попадали все мы.

Команда `git reflog` показывает список всего, что вы сделали. Затем она позволяет воспользоваться инструментами `Git` для отката изменений, для возврата к одному из прошлых состояний репозитория. Стоит отметить, что этот метод стоит рассматривать как последнее средство, и, прежде чем им воспользоваться, стоит как следует подумать. Итак, вывести список того, что было сделано, можно следующей командой:

```
git reflog
```
`Git` помнит все наши действия и в результате выполнения этой команд можно увидеть примерно следующее:

```
3ff8691 (HEAD -> feature-branch) HEAD@{0}: Branch: renamed refs/heads/feature-brunch to refs/heads/feature-branch
3ff8691 (HEAD -> feature-branch) HEAD@{2}: checkout: moving from master to feature-brunch
2b7e508 (master) HEAD@{3}: reset: moving to HEAD~
3ff8691 (HEAD -> feature-branch) HEAD@{4}: commit: Adds the client logo
2b7e508 (master) HEAD@{5}: reset: moving to HEAD~1
37a632d HEAD@{6}: commit: Adds the client logo to the project
2b7e508 (master) HEAD@{7}: reset: moving to HEAD
2b7e508 (master) HEAD@{8}: commit (amend): Added contributing info to the site
dfa27a2 HEAD@{9}: reset: moving to HEAD
dfa27a2 HEAD@{10}: commit (amend): Added contributing info to the site
700d0b5 HEAD@{11}: commit: Addded contributing info to the site
efba795 HEAD@{12}: commit (initial): Initial commit
```

Обратите внимание на самую левую колонку этого списка. Тут содержатся индексы. Если вам нужно вернуться назад, в некий момент прошлого, выполните следующую команду, заменив `{index} `соответствующей ссылкой, например — dfa27a2. Выглядит эта команда так:


```
git reset HEAD@{index}
```

# Работа с удаленными репозиториями.

[__Что такое удаленный репозитория__](#с1)


[__Подключение к удаленному репозиторию__](#d1)






<a id ="с1"></a>
## Что такое удаленный репозитория
Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.
Клонирование
Клонирование - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него. В нашем руководстве мы будем использовать адрес `https://github.com/tutorialzine/awesome-project`, но вам посоветуем, попробовать создать свой репозиторий в GitHub, BitBucket или любом другом сервисе:

```
git clone https://github.com/tutorialzine/awesome-project
```

При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория .git, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию, например:

```
git clone https://github.com/tutorialzine/awesome-project new-folder
```

<a id ="d1"></a>
## Подключение к удаленному репозиторию

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
Чтобы связать наш локальный репозиторий с репозиторием на `GitHub`, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

